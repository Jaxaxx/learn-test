# 线程池

## 简介

    线程Thread 是一个重量级资源，线程的创建，启动以及销毁都是比较耗费系统资源的，同事受限于系统资源的限制，线程的数量和系统性能是一种抛物线的关系，因此对线程的管理是一种非常重要的程序设计习惯。
    
    自jdk1.5起，juc包提供了ExecutorService线程池的实现，通俗的讲：为了避免重复的创建线程，线程池的出现可以让线程进行复用当有任务来，就会向线程池拿一个线程，当工作完成后，并不是直接关闭线程，而是将这个线程归还给线程池供其他任务使用。
    
    一个线程池包括以下四个基本组成部分：
        1. 线程池管理器： ThreadPool 用于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；
        2. 工作线程：PoolWorker 线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；
        3. 任务接口 Task 每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等；
        4. 任务队列 tashQueue 用于存放没有处理的任务，提供一种缓冲机制
        
## 线程池的作用
    
    线程池作用就是限制系统中执行线程的数量
    
    根据系统环境情况 手动或自动设置线程数量，达到运行的最佳效果；少了浪费了系统资源，多了造成系统拥挤效率不高。用线程池控制线程数量,其他线程排对等待。一个任务执行完毕，再从队列中取最前面的任务开始执行，若队列中没有等待线程，线程池的这一资源处于等待，当一个新任务需要运行时,如果线程池中有等待的工作线程，就可以开始运行了；否则进入等待队列。
        1. 减少了创建和和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。
        2. 可以根据系统的承受能力，调整线程池中工作线程的数目，防止因线程过多消耗内存，也避免了因线程太少浪费系统资源。
            
## 线程池的创建
    
    Java里边线程池的顶级接口时Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具，真正的线程接口时ExecutorService，要配置一个线程池时比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在Executors类里边提供了一些静态工厂，生成一些常用的线程池。
    
    1.newSingleThreadExecutor 
        初始化只有一个线程的线程池，内部使用LinkedBlockingQuene作为阻塞队列。
        相当于单线程串行执行所有任务，如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行
    2.newFixedThreadPool 
        初始化一个指定线程数的线程池，其中corePoolSize == maxiPoolSize，使用LinkedBlockingQuene作为阻塞队列
        每次提交一个任务就创建一个线程，知道线程达到线程池的最大大小，线程池的大小一旦达到最大值就会保持不变，即使当线程池没有可执行任务时，也不会
        释放线程，如哦某个线程因为执行异常而结束，那么线程池就会补充一个新的线程。
    3.newCachedThreadPool
        初始化一个可以缓存线程的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。
        线程池的线程数可达到Interger.MAX_VALUE,即2147483647，内部使用SynvhronousQueue作为阻塞队列。
    4.newScheduledThreadPool 
        初始化的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期的同步数据。
        
    除了newScheduledThreadPool的内部实现特殊一点之外，其他线程池内部都是基于ThreadPoolExecutor类实现的。
    
## 线程池的状态
    
    其中Atomiclnteger变量ctl的功能非常强大，利用低29位表示线程池中线程数，通过高3位表示线程池的运行状态；
        1.RUNNING ： -1 << COUNT_BITS ，即高3位为111，该状态的线程池会接受新任务，并处理阻塞队列中的任务
        2.SHUTDOWN : 0 << COUNT_BITS , 即高三位为000，该状态的线程池不会接受新任务，但会处理阻塞队列中的任务
        3.STOP ： 1 << COUNT_BITS , 即高三位为001，该状态的线程不会接受新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；
        4.TIDYING : 2 << COUNT_BITS ， 即高三位为010 该状态表使线程池对线程进行整理优化
        5.TERMINATED ： 3 << COUNT_BITS , 即高三位为011，该状态表示线程池停止工作
        
## 线程池的关闭
    
    ThreadPoolExecutor 提供了两种方法，用于线程池的关闭，分别是shutdown() 和 shutdownNow(),启动：
        1.shutdown(): 不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务
        2.shutdownNow() : 立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务